// 1. 상수
	final 자료명 변수명;

// 2. 구구단 출력

// 3. 오버로드(오버라이드와 구분)
	// 생성자 오버로드
	생성자가 2개 이상 제공되는 경우를 말한다.
	메서드나 생성자의 매개변수 개수가 다르거나 타입이 다른 경우를 말하며, 리턴타입과는 무관하다.

// 4. 접근제어자
	private -> default -> protected -> public
	 
// 5. 상속
	    * 상속 : 자식클래스 extends 부모클래스 { .... }
	    * - extends : 확장하다의 의미
	    * - 공통으로 사용하는 멤버변수와 멤버메서드를 부모클래스에서 정의한다.
	    * - 부모클래스는 일반적이고 공통적이며, 자식클래스는 구체적이고 유일하다.
	    * 
	    * - 사용이유 : 부모클래스의 멤버변수와 멤버메서드를 재사용.
	    *          중복되는 코드를 줄임으로써 손쉽게 개발, 유지보수 가능
	    * - 부모클래스의 멤버를 private으로 선언한 경우, 자식클래스에서 접근할 수 없다.
	    *   접근제어자 protected의 경우 자식클래스에서 접근 가능
	    
// 6. 오버라이딩
	 * [면접] 오버로드 VS 오버라이드
	 * @Override 어노테이션 : "이 메서드는 재정의된 메서드입니다."라고 컴파일러에게 명확히 알려주는 역할을 한다.
	 * 오버라이딩(=재정의)
	 * - 자식클래스의 메서드가 부모클래스의 메서드를 오버라이드(재정의)한다라고 말한다.
	 * - 상속에서 부모클래스의 메서드를 변경하고자 할 때 사용한다.
	 * - 메서드명, 매개변수, 매개변수 자료형, 반환형까지 모두 동일해야 한다.
	 *  (동일하지 않으면 컴파일러가 다른 메서드로 인식한다.)
	 * - 호출시 오버라이딩된 자식메서드가 호출된다.
	 *  (오버라이드 목적 : 부모클래스의 메서드를 변경해서 자식쪽에서 호출하고자 하는 의도)

// 7. 추상클래스
       * 1. 추상클래스 => 업무표준화, 작업명세서 : 정의된 추상메서드
       * - 하나 이상의 추상메서드를 가지고 있는 클래스를 의미한다.
       * - abstract 키워드를 이용하여 구현되지 않는 추상메서드를 기술할 수 있다.
       * - 자식클래스에게 구현을 위임하고자 할 때 사용되며, 프로그램의 확장성을 취해 많이 사용하는 설계방법이다.
       * - 추상클래스는 일반메서드, 추상메서드 모두 올 수 있다.
       * - 전제조건은 반드시 상속을 해야 한다.
       * - 다형성 적용 가능하다.
       * 
       * - 문법 : public abstract class 클래스명 {
       *             public abstract 반환형 메서드명();  // 추상메서드
       *       }
       
// 8. 인터페이스
	 * [ 추상클래스 vs 인터페이스 ]
	 *       인터페이스 설명
	 *       
	 *  인터페이스 
	 *  - 기능정의서(표준 작업명세서)이다. - 강제성과 통일성
	 *  - 설계(선언)와 구현을 분리시키는 것을 가능하게 한다.
	 *    (설계 : 인터페이스, 구현 : 자식클래스)
	 *  - 객체생성 불가능하며, 객체 Type으로 가능하다.(다형성 적용)
	 *  - 인터페이스의 멤버는 상수(static final 생략 가능), 추상메서드(abstract 생략 가능)만 올수 있다.
	 *  - 단 static 메서드, 디폴트 메서드, private 메서드는 예외(JDK 1.8부터)
	 *  - 인터페이스를 implements(=구현)할 자식클래스에서 추상메서드를 재정의한다.
	 *  
	 *  1. 인터페이스 작성
	 *  interface 인터페이스명 {
	 *     // 상수
	 *     public static final 데이터타입 대문자상수명 = 값;
	 *      // 추상메서드
	 *      public abstract 반환형 추상메서드(매개변수1,...);  // body없다
	 *  }
	 *  
	 *  2. 인터페이스 구현  
	 *  자식class 클래스명 implements 인터페이스명 {
	 *     @Override
	 *      public 반환형 추상메서드(매개변수1,...) {
	 *          // 인터페이스에 정의된 추상메서드를 구현해야 한다.
	 *       }
	 *  }
	 *  
	 * 3. 인터페이스는 다중 상속 가능    cf) 클래스는 단일 상속만 가능
	 * interface 인터페이스명  extends  인터페이스명1, .. 인터페이스명n {
	 * 
	 * }

 
// 9. ArrayList
       *  1. 특징
       *  List 인터페이스 : 순서가 있는 자료관리, 중복허용한다.
       *                 index를 사용하여 요소에 접근한다.
       *                 리스트에 들어있는 요소들의 인덱스는 0부터 시작한다.
       *                 클래스종류는 ArrayList, Vector, LinkedList
       *                 
       *  Set 인터페이스 : 순서가 없는 자료관리, 중복허용 않는다.
       *                클래스종류는 HashSet, TreeSet
       * 
       * 2. 선언
       * 클래스명<데이터타입클래스> 참조변수 = new 클래스명<데이터타입클래스>();
       * ArrayList<String> list = new ArrayList<String>();
       * String[] arr = new String[5];  // 배열 : 정해진갯수만큼
       * 
       * 다형성 적용
       * List<String> list = new ArrayList<String>();
       * 
       * 3. 특징 : 데이터 순서가 있다. 중복허용된다.
       * 4. 추가 : list.add(값);  // 앞에서부터 순서대로 추가
       *         list.add(추가할 위치 index, 값);  // 지정한 인덱스에 값을 추가, 그 뒤의 값은 밀려난다.
       * 5. 값 가져오기 : list.get(가져올 index);   // list.size()만큼 반복        
       * 6. 교체 : list.set(교체할 위치 index, 값); // 지정한 인덱스의 값을 변경.. 그 뒤값은 그대로이다.
       * 7. 삭제 : list.remove(삭제할 위치 index);
       * 8. 검색 : list.indexOf(검색할 값);    // 중요
       *         => 리스트에서 검색할 값과 똑같은 값을 갖는 첫번째 데이터를 찾아서 그 위치의 인덱스를 리턴한다.
       *
       *         list.lastIndexOf(검색할 값)
       *          => 리스트에서 검색할 값과 똑같은 값을 갖는 마지막번째 데이터를 찾아서 그 위치의 인덱스를 리턴한다.         
       *
       *         검색할 값과 일치한 데이터가 없으면 -1을 리턴한다.
       *         
       * 9. 전체 삭제 : list.clear();
       * 10. 반복자 : Iterator<E> iterator : while(hasNext())  { next() }
       
// 10. HashMap
       * 해싱(hashing) : 키를 이용해서 해시테이블로부터 데이터를 가져오는 과정
       * 
       * HashMap
       * 1) 특징
       * - 데이터의 순서를 보장하지 않는다.
       * - key와 value 쌍으로 저장한다.
       * - key는 중복되면 안된다. 값은 중복되도 무관하다.
       * - key를 이용해서 value를 가져올 수 있다.
       * - List 계열과 달리 index가 없다.
       * - Map이라는 인터페이스를 구현한 클래스이다.
       * 
       * 2) 선언
       * - HashMap<Key 클래스타입, value 클래스타입> map = new HashMap<Key 클래스타입, value 클래스타입>();
       * - Map<Key 클래스타입, value 클래스타입> map = new HashMap<Key 클래스타입, value 클래스타입>(); // 다형성 적용
       * 
       * 3) 메서드
       * - 데이터 추가 : put(key, value);
       * - 데이터 가져오기 : get(key)
       * - 데이터 삭제 : remove(key)
       * - 데이터가 비어있는지 여부 : isEmpty()
       * - 해당 키가 있는지 여부 : containsKey(key)
       * - 해당 값이 있는지 여부 : containsValue(value)
       * - 해당 갯수 : size()
     
// 11. 예외 처리
       * 예외 처리 목적 : 정상종료
       * 
       * try {
       *      // 예외가 발생할 수 있는 코드 부분
       * } catch(처리할 예외타입 e) {
       *    // try 블록안에서 예외가 발생했을 때 예외를 처리하는 부분
       * } finally {
       *      // 항상 수행되는 부분(예외가 발생하지 않더라도) 
       *    // 주로 자원해제를 위한 close() 문장이 온다.
       * }
       * 1. 강제예외발생 : throw new Exception(message);
       * 2. 상위 메서드에게 예외 던지기
       *    throws Exception
       * 3. 예외 처리
       *    catch(던진 Exception e){e.getMaessage()}로 받는다.
       * 
       * catch문이 여러개일때(다중 catch) 부모 Exception이 제일 아래오도록 한다. 실행순서는 위에서부터 실행
   
// 12. 싱글톤
	 	 * [ 싱글톤패턴 ]
		 * - 인스턴스를 단 하나만 생성하는 디자인 패턴
		 * - static을 응용하여 프로그램 전반에서 사용하는 동일한 인스턴스를 하나만 생성하는 방식
		 * - 접근할 클래스에 여러 메서드가 있을 때, 외부 클래스가 해당 메서드에 접근할 때마다 
		 *   객체를 생성할 필요없이 메서드를 통해 참조변수만 리턴받아 접근한다.
		 *   열번, 백번을 호출해도 항상 같은 주소의 인스턴스가 반환된다.
		 *  
		 * 싱글톤패턴 생성
		 * - 1단계. 디폴트생성자를 private으로 만들기
		 * - 2단계. 클래스 내부에 static으로 유일한 인스턴스 생성하기
		 * - 3단계. 외부에서 참조할 수 있는 public 메서드 만들기
		 * 
		 * 호출
		 * - 접근클래스명 참조변수 = 접근클래스명.메서드명;
---------------------------------------------------------------------